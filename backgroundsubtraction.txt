//opencv
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/imgproc/imgproc.hpp>

//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

//global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat fgMaskMOG22;
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;
vector<vector<Point>> contours_fgMaskMOG22;//find the contour
//Mat contourImage;//draw the contour

Size size(620, 460);//to resize the pictures
int useforsaveimg = 0;


//function declarations
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void drawAxis(Mat&, Point, Point, Scalar, const float);
double getOrientation(const vector<Point> &, Mat&);
int dopca(Mat &src);
float anglebetween(const Point &p1, const Point &p2, const Point &p3);

void help()
{
		cout
		<< "--------------------------------------------------------------------------" << endl
		<< "This program shows how to use background subtraction methods provided by " << endl
		<< " OpenCV. You can process both videos (-vid) and images (-img)." << endl
		<< endl
		<< "Usage:" << endl
		<< "./bs {-vid <video filename>|-img <image filename>}" << endl
		<< "for example: ./bs -vid video.avi" << endl
		<< "or: ./bs -img /data/images/1.png" << endl
		<< "--------------------------------------------------------------------------" << endl
		<< endl;
}

int main(int argc, char* argv[])
{
	//print help information
	help();
	argc = 3;
	argv[1] = "-img";
	argv[2] = "0.jpg";
	//check for the input parameter correctness
	if (argc != 3) {
		cerr << "Incorret input list" << endl;
		cerr << "exiting..." << endl;
		return EXIT_FAILURE;
	}


	//create Background Subtractor objects
	//NOTE HERE!!!!
	pMOG = new BackgroundSubtractorMOG(); //MOG approach
	pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach

	BackgroundSubtractorMOG2 pMOG3;

	if (strcmp(argv[1], "-vid") == 0) {
		//input data coming from a video
		processVideo(argv[2]);
	}
	else if (strcmp(argv[1], "-img") == 0) {
		//input data coming from a sequence of images
		processImages(argv[2]);
	}
	else {
		//error in reading input parameters
		cerr << "Please, check the input parameters." << endl;
		cerr << "Exiting..." << endl;
		return EXIT_FAILURE;
	}
	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
	//create the capture object
	VideoCapture capture(videoFilename);
	if (!capture.isOpened()){
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}
	//read input data. ESC or 'q' for quitting
	while ((char)keyboard != 'q' && (char)keyboard != 27){
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}
		//update the background model
		//AND HERE!!!
		pMOG->operator()(frame, fgMaskMOG);
		pMOG2->operator()(frame, fgMaskMOG2);
		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(255, 255, 255), -1);
		ss << capture.get(CV_CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
		//show the current frame and the fg masks
		imshow("Frame", frame);
		imshow("FG Mask MOG", fgMaskMOG);
		imshow("FG Mask MOG 2", fgMaskMOG2);
		//get the input from the keyboard
		keyboard = waitKey(30);
	}
	//delete capture object
	capture.release();
}

void processImages(char* fistFrameFilename) {
	//read the first file of the sequence
	frame = imread(fistFrameFilename);
	if (!frame.data){
		//error in opening the first image
		cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
		exit(EXIT_FAILURE);
	}
	//resize images
	resize(frame,frame,size);
	//current image filename
	string fn(fistFrameFilename);
	//read input data. ESC or 'q' for quitting

	pMOG2->set("detectShadows",1);
	while ((char)keyboard != 'q' && (char)keyboard != 27){
		//update the background model
		//ALSO HERE!!!!

		pMOG->operator()(frame, fgMaskMOG);
		pMOG2->operator()(frame, fgMaskMOG2);
		
		threshold(fgMaskMOG2, fgMaskMOG22, 50, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
		//threshold(fgMaskMOG2, fgMaskMOG22,127,255,0);
		//get the frame number and write it on the current frame
		size_t index = fn.find_last_of("/");
		if (index == string::npos) {
			index = fn.find_last_of("\\");
		}
		size_t index2 = fn.find_last_of(".");
		string prefix = fn.substr(0, index + 1);
		string suffix = fn.substr(index2);
		string frameNumberString = fn.substr(index + 1, index2 - index - 1);
		istringstream iss(frameNumberString);
		int frameNumber = 0;
		iss >> frameNumber;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(255, 255, 255), -1);
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
		//show the current frame and the fg masks
		imshow("Frame", frame);

		//remove noises and fill the holes
		Size ksize = Size(5, 5);
		Mat kernel = getStructuringElement(MORPH_RECT, ksize);

		morphologyEx(fgMaskMOG22, fgMaskMOG22, MORPH_ERODE, kernel, Point(-1, -1), 1);
		morphologyEx(fgMaskMOG22, fgMaskMOG22, MORPH_DILATE, kernel, Point(-1, -1), 4);
		morphologyEx(fgMaskMOG22, fgMaskMOG22, MORPH_ERODE, kernel, Point(-1, -1), 4);
		imshow("morphologyEx", fgMaskMOG22);
		
		
		////save images for pca in the next step
		//Mat fgMaskMOG22_for_pca = fgMaskMOG22.clone();
		//ostringstream convert;
		//convert << "pcatest0" << useforsaveimg << ".jpg";
		//imwrite(convert.str().c_str(), fgMaskMOG22_for_pca);
		//useforsaveimg += 1;

		//pca analyse to bw frame after morphology exchange
		//dopca(fgMaskMOG22);
		//imshow("after pca fgMaskMOG22", fgMaskMOG22);

		int zz = countNonZero(fgMaskMOG22);//quantity of pixels

		cout <<"number of pixels: "<< zz << endl;
		
		

		//get the input from the keyboard
		//keyboard = waitKey();
		//search for the next image in the sequence

		if (zz > 0)
		{
			////draw horizontal projection
			//Mat horizontal(fgMaskMOG22.cols, 1, CV_32S);
			//horizontal = Scalar::all(0);
			//Mat draw_horizontal(fgMaskMOG22.size(), CV_8UC3, Scalar(0, 0, 0));

			//for (int i = 0; i < fgMaskMOG22.cols; i++)
			//{
			//	horizontal.at<int>(i, 0) = countNonZero(fgMaskMOG22(Rect(i,0,1,fgMaskMOG22.rows)));
			//	//cout << i<<" horizontal " << horizontal.at<int>(i, 0) << endl;
			//	line(draw_horizontal, Point(i, 0), Point(i, horizontal.at<int>(i, 0)), CV_RGB(0, 0, 255));

			//}
			//flip(draw_horizontal, draw_horizontal, 0);
			////imshow("drawHorizontal", draw_horizontal);

			////draw vertical projection and find the neck
			//Mat vertical(fgMaskMOG22.rows, 1, CV_32S);
			//vertical = Scalar::all(0);
			//Mat draw_vertical(fgMaskMOG22.size(), CV_8UC3, Scalar(0, 0, 0));
			//int no_of_pixel_vertical;
			//int t1=0;
			//for (int i = 0; i < fgMaskMOG22.rows; i++)
			//{
			//	vertical.at<int>(i, 0) = countNonZero(fgMaskMOG22(Rect(0, i, fgMaskMOG22.cols, 1)));
			//	//cout << i << " vertical " << vertical.at<int>(i, 0) << endl;
			//	//if (vertical.at<int>(i, 0) < 10)vertical.at<int>(i, 0) = 0;
			//	line(draw_vertical, Point(0, i), Point(vertical.at<int>(i, 0), i), CV_RGB(0, 0, 255));
			//	if (vertical.at<int>(i, 0)>50) no_of_pixel_vertical = vertical.at<int>(i, 0);
			//}
			//for (int i = fgMaskMOG22.rows/2; i < fgMaskMOG22.rows; i++)
			//{
			//	if (no_of_pixel_vertical>vertical.at<int>(i, 0) && vertical.at<int>(i, 0)>50)
			//	{
			//		no_of_pixel_vertical = vertical.at<int>(i, 0);
			//		t1 = i;
			//	}
			//}
			//line(draw_vertical, Point(0, t1), Point(vertical.at<int>(t1, 0), t1), CV_RGB(255, 0, 0));
			////line(contours_fgMaskMOG22, Point(0, t1), Point(vertical.at<int>(t1, 0), t1), CV_RGB(255, 0, 0));
			////imshow("drawVertical", draw_vertical);

			//
			////find contours
			//Mat foreground = fgMaskMOG22.clone();
			//findContours(fgMaskMOG22, contours_fgMaskMOG22, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
			//
			//int largest_area = 0;//to find the largest contour
			//int largest_contour_index = 0;//to find the largest contour
			//Mat contourImage(fgMaskMOG22.size(), CV_8UC3, Scalar(0, 0, 0));
			//Mat contourImage_approx(fgMaskMOG22.size(), CV_8UC3, Scalar(0, 0, 0));
			//vector<vector<Point>> contour_approx(contours_fgMaskMOG22.size());

			//Scalar colors[3];
			//colors[0] = cv::Scalar(255, 0, 0);
			//colors[1] = cv::Scalar(0, 255, 0);
			//colors[2] = cv::Scalar(0, 0, 255);
			////to find the largest contour
			//for (size_t idx = 0; idx < contours_fgMaskMOG22.size(); idx++)
			//{
			//	double a = contourArea(contours_fgMaskMOG22[idx],false);
			//	if (a>largest_area)
			//	{
			//		largest_area = a;
			//		largest_contour_index = idx;
			//	}
			//}
			////moving average contour
			//approxPolyDP(Mat(contours_fgMaskMOG22[largest_contour_index]), contour_approx[largest_contour_index], 5, true);
			////draw the contour
			//drawContours(contourImage, contours_fgMaskMOG22, largest_contour_index, colors[largest_contour_index % 3]);
			//drawContours(contourImage_approx, contour_approx, largest_contour_index, colors[largest_contour_index % 3]);
			//
			////save contour images for pca in the next step
			///*Mat contourImage_approx_for_pca = contourImage_approx.clone();
			//ostringstream convert;
			//convert << "pcatest" << useforsaveimg << ".jpg";
			//imwrite(convert.str().c_str(),contourImage_approx_for_pca);
			//useforsaveimg += 1;*/

		
			//Point center;
			//for (int i = 0; i < contour_approx[largest_contour_index].size()-2; i++)
			//{
			//	float angle = anglebetween(contour_approx[largest_contour_index][i], contour_approx[largest_contour_index][i+1], contour_approx[largest_contour_index][i+2]);
			//	cout << "angle between" << contour_approx[largest_contour_index][i] << "and" << contour_approx[largest_contour_index][i+1] << "and" << contour_approx[largest_contour_index][i+2] << "is " << angle<<endl;
			//	center = contour_approx[largest_contour_index][i];
			//	circle(contourImage_approx, center, 1, CV_RGB(255, 0, 0), 3);
			//}

			////draw the line across neck
			//line(contourImage_approx, Point(0, t1), Point(fgMaskMOG22.cols, t1), CV_RGB(255, 0, 0));
			//
			//Mat headROI;
			//if (t1 <= 0) t1 = 1;
			//headROI = foreground(Rect(0, 0, foreground.cols,t1));
			//imshow("headROI", headROI);
			//Mat torsoROI = foreground(Rect(0, t1, foreground.cols, foreground.rows-t1));
			//imshow("torsoROI",torsoROI);
			////save contour images for pca in the next step
			//string s = "headforpca"+to_string(useforsaveimg)+".jpg";
			//imwrite(s,headROI);
			//string d = "torsoforpca"+to_string(useforsaveimg)+".jpg";
			//imwrite(d,torsoROI);
			//useforsaveimg += 1;

			//imshow("contour_approx",contourImage_approx);
			keyboard = waitKey();
		}
		
		ostringstream oss;
		oss << (frameNumber + 1);
		string nextFrameNumberString = oss.str();
		string nextFrameFilename = prefix + nextFrameNumberString + suffix;
		//read the next frame 
		frame = imread(nextFrameFilename);
		if (!frame.data){
			//error in opening the next image in the sequence
			cerr << "Unable to open image frame: " << nextFrameFilename << endl;
			exit(EXIT_FAILURE);
		}
		resize(frame, frame, size);
		//update the path of the current frame
		fn.assign(nextFrameFilename);
	}
}

float anglebetween(const Point &p1, const Point &p2, const Point &p3)
{
	Point v1 = p1 - p2;
	Point v2 = p3 - p2;

	float len1 = sqrt(v1.x*v1.x + v1.y*v1.y);
	float len2 = sqrt(v2.x * v2.x + v2.y * v2.y);

	float dot = v1.x * v2.x + v1.y * v2.y;

	float a = dot / (len1 * len2);

	if (a >= 1.0)
		return 0.0;
	else if (a <= -1.0)
		return 180;
	else
		return acos(a) * 180 / 3.14; // 0..PI
}

void drawAxis(Mat& img, Point p, Point q, Scalar colour, const float scale = 0.2)
{
	double angle;
	double hypotenuse;
	angle = atan2((double)p.y - q.y, (double)p.x - q.x); // angle in radians
	hypotenuse = sqrt((double)(p.y - q.y) * (p.y - q.y) + (p.x - q.x) * (p.x - q.x));
	//    double degrees = angle * 180 / CV_PI; // convert radians to degrees (0-180 range)
	//    cout << "Degrees: " << abs(degrees - 180) << endl; // angle in 0-360 degrees range
	// Here we lengthen the arrow by a factor of scale
	q.x = (int)(p.x - scale * hypotenuse * cos(angle));
	q.y = (int)(p.y - scale * hypotenuse * sin(angle));
	line(img, p, q, colour, 1, CV_AA);
	// create the arrow hooks
	p.x = (int)(q.x + 9 * cos(angle + CV_PI / 4));
	p.y = (int)(q.y + 9 * sin(angle + CV_PI / 4));
	line(img, p, q, colour, 1, CV_AA);
	p.x = (int)(q.x + 9 * cos(angle - CV_PI / 4));
	p.y = (int)(q.y + 9 * sin(angle - CV_PI / 4));
	line(img, p, q, colour, 1, CV_AA);
}
double getOrientation(const vector<Point> &pts, Mat &img)
{
	//Construct a buffer used by the pca analysis
	int sz = static_cast<int>(pts.size());
	Mat data_pts = Mat(sz, 2, CV_64FC1);
	for (int i = 0; i < data_pts.rows; ++i)
	{
		data_pts.at<double>(i, 0) = pts[i].x;
		data_pts.at<double>(i, 1) = pts[i].y;
	}
	//Perform PCA analysis
	PCA pca_analysis(data_pts, Mat(), CV_PCA_DATA_AS_ROW);
	//Store the center of the object
	Point cntr = Point(static_cast<int>(pca_analysis.mean.at<double>(0, 0)),
		static_cast<int>(pca_analysis.mean.at<double>(0, 1)));
	//Store the eigenvalues and eigenvectors
	vector<Point2d> eigen_vecs(2);
	vector<double> eigen_val(2);
	for (int i = 0; i < 2; i++)
	{
		eigen_vecs[i] = Point2d(pca_analysis.eigenvectors.at<double>(i, 0),
			pca_analysis.eigenvectors.at<double>(i, 1));
		eigen_val[i] = pca_analysis.eigenvalues.at<double>(i, 0);
	}
	// Draw the principal components
	circle(img, cntr, 3, Scalar(255, 0, 255), 2);
	Point p1 = cntr + 0.02 * Point(static_cast<int>(eigen_vecs[0].x * eigen_val[0]), static_cast<int>(eigen_vecs[0].y * eigen_val[0]));
	Point p2 = cntr - 0.02 * Point(static_cast<int>(eigen_vecs[1].x * eigen_val[1]), static_cast<int>(eigen_vecs[1].y * eigen_val[1]));
	drawAxis(img, cntr, p1, Scalar(0, 255, 0), 1);
	drawAxis(img, cntr, p2, Scalar(255, 255, 0), 5);
	double angle = atan2(eigen_vecs[0].y, eigen_vecs[0].x); // orientation in radians
	return angle;
}

int dopca(Mat &src)
{
	// Load image

	//Mat src = imread(argv[1]);
	// Check if image is loaded successfully
	if (!src.data || src.empty())
	{
		cout << "Problem loading image!!!" << endl;
		return EXIT_FAILURE;
	}
	imshow("src", src);
	// Convert image to grayscale
	//Mat gray;
	//cvtColor(src, gray, COLOR_BGR2GRAY);
	// Convert image to binary
	Mat bw;
	threshold(src, bw, 50, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);


	// Find all the contours in the thresholded image
	vector<Vec4i> hierarchy;
	vector<vector<Point> > contours;
	findContours(bw, contours, hierarchy, CV_RETR_LIST, CV_CHAIN_APPROX_NONE);
	for (size_t i = 0; i < contours.size(); ++i)
	{
		// Calculate the area of each contour
		double area = contourArea(contours[i]);
		// Ignore contours that are too small or too large
		if (area < 1e2 || 1e10 < area) continue;
		// Draw each contour only for visualisation purposes
		drawContours(src, contours, static_cast<int>(i), Scalar(0, 0, 255), 2, 8, hierarchy, 0);
		// Find the orientation of each shape
		getOrientation(contours[i], src);
	}
	imshow("output", src);
	waitKey(0);
	return 0;
}